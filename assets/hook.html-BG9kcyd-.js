import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as d,d as e,a as o,b as a}from"./app-ZYb1lyrt.js";const s={},n=o('<h1 id="hooks" tabindex="-1"><a class="header-anchor" href="#hooks"><span>hooks</span></a></h1><h2 id="hooks的使用" tabindex="-1"><a class="header-anchor" href="#hooks的使用"><span>hooks的使用</span></a></h2><h4 style="color:red;">为什么要用Hook?</h4>',3),l=a("br",null,null,-1),i=o(`<ul><li><code>Hook</code> 使你在无需修改组件结构的情况下复用状态逻辑。</li></ul><p>2.复杂组件变得难以理解</p><ul><li><code>Hook</code> 将组件中<code>相互关联</code>的部分<code>拆分</code>成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 <code>reducer</code> 来管理组件的内部状态，使其更加可预测。</li></ul><p>3.难以理解的 class</p><ul><li><code>Hook</code> 使你在非 <code>class</code> 的情况下可以使用更多的 <code>React</code> 特性</li></ul><h4 style="color:red;">什么是 Hook?</h4><ul><li><code>Hook</code> 是一些可以让你在<code>函数组件</code>里<code>“钩入” React state</code> 及<code>生命周期等特性</code>的<code>函数</code>。<code>Hook</code> <code>不能</code>在 <code>class 组件</code>中使用 —— 这使得你不使用 <code>class</code> 也能使用 <code>React</code>。</li></ul><h4 style="color:red;">什么是 &quot;副作用&quot;?</h4><ul><li>你之前可能已经在 <code>React</code> 组件中执行过数据<code>获取、订阅</code>或者<code>手动修改</code>过 <code>DOM</code>。我们统一把这些操作称为<code>“副作用”</code>，或者简称为<code>“作用”</code>。</li></ul><h2 id="usestate" tabindex="-1"><a class="header-anchor" href="#usestate"><span>useState</span></a></h2><h4 style="color:red;">调用 useState 方法的时候做了什么?</h4><ul><li>它定义一个 <code>“state 变量”</code>,一般来说，在<code>函数退出</code>后<code>变量</code>就<code>会”消失”</code>，而 <code>state</code> 中的变量会被<code> React 保留</code>。</li></ul><h4 style="color:red;">useState 需要哪些参数？</h4><p>-<code>useState()</code> 方法里面唯一的参数就是初始 <code>state</code>;想初始化两个变量，就调用两次<code>useState()</code></p><h4 style="color:red;">useState 方法的返回值是什么？</h4><ul><li>返回值为：当前 <code>state</code> 以及<code>更新 state 的函数</code>。这就是我们写 <code>const [count, setCount] = useState()</code> 的原因; 使用的 <code>[]</code> 中括号</li></ul><h2 id="useeffect" tabindex="-1"><a class="header-anchor" href="#useeffect"><span>useEffect</span></a></h2><h3 id="_1-useeffect-介绍" tabindex="-1"><a class="header-anchor" href="#_1-useeffect-介绍"><span>1.useEffect 介绍</span></a></h3><h4 style="color:red;">useEffect 做了什么？</h4><ul><li>它告诉 <code>React 组件</code>需要在<code>渲染后</code>执行某些操作。<code>React</code> 会<code>保存</code>你<code>传递的函数</code>（我们将它称之为 “effect”），并且在执行 <code>DOM 更新之后调用它</code>。</li></ul><h4 style="color:red;">为什么在组件内部调用 useEffect？</h4><p>-将 <code>useEffect</code> 放在组件内部让我们可以在 <code>effect</code> 中直接访问<code> count state</code> 变量（或其他 <code>props</code>）;<code>Hook</code> 使用了 <code>JavaScript</code> 的<code>闭包机制</code>，而不用在 <code>JavaScript</code> 已经提供了解决方案的情况下，还引入特定的 <code>React API</code>。</p><h4 style="color:red;">useEffect 会在每次渲染后都执行吗？</h4><ul><li>它在<code>第一次渲染之后</code>和<code>每次更新之后</code>都会执行;<code>React</code> 保证了每次运行 <code>effect</code> 的同时，<code>DOM</code> 都已经<code>更新完毕</code>。</li></ul><h4 style="color:red;">useEffect 是不是异步？</h4><ul><li><code>是异步</code>；如果需要<code>effect 同步</code>的话，有单独的 <code>useLayoutEffect Hook</code> 供你使用，其 <code>API</code> 与 <code>useEffect</code> 相同。</li></ul><h4 style="color:red;">useEffect 的优势？</h4><ul><li>与 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 不同，使用 <code>useEffect</code> 调度的 <code>effect</code> <code>不会阻塞浏览器更新屏幕</code>，这让你的应用看起来<code>响应更快。</code></li></ul><h3 id="_2-需要清除的-effect" tabindex="-1"><a class="header-anchor" href="#_2-需要清除的-effect"><span>2.需要清除的 effect</span></a></h3><p><code>useEffect</code> 的设计是在同一个地方执行。如果你的 <code>effect</code> 返回一个函数，<code>React</code> 将会在<code>执行清除操作时调用它</code></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 渲染时执行 相当于clas组件的 componentDidMount componentDidUpdate </span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 组件卸载时执行 相当于clas组件的</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注1 例：[count] 仅在count 更改时更新 componentWillUnmount</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><ol><li>如果使用<code>注1</code>这种优化方式，请确保数组中包含了<code>所有外部作用域</code>中会随时间变化并且在 <code>effect</code> 中使用的变量，否则你的代码会引用到先前渲染中的旧变量;</li><li>如果想执行<code>只运行一次</code>的 <code>effect</code>（仅在组件<code>挂载</code>和<code>卸载</code>时执行），可以传递一个<code>空数组（[]）</code>作为第二个参数。</li></ol></div><h2 id="hook-规则" tabindex="-1"><a class="header-anchor" href="#hook-规则"><span>Hook 规则</span></a></h2><ol><li>只在最顶层使用 Hook</li></ol><ul><li><code>不要</code>在<code>循环，条件或嵌套函数</code>中调用 <code>Hook</code>， 确保总是在你的 <code>React</code> <code>函数的最顶层调用他们</code>。 遵守这条规则，你就能确保 <code>Hook</code> 在每一次渲染中都按照同样的顺序被调用。这让 <code>React</code> 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 <code>hook</code> 状态的正确。</li></ul><ol start="2"><li>只在 React 函数中调用 Hook</li></ol><ul><li>不要在普通的 <code>JavaScript</code> 函数中调用 <code>Hook</code>。</li><li>在 <code>React</code> 的函数组件中调用 <code>Hook</code></li><li>在自定义 <code>Hook</code> 中调用其他 <code>Hook</code></li></ul><h2 id="自定义hook" tabindex="-1"><a class="header-anchor" href="#自定义hook"><span>自定义Hook</span></a></h2><ul><li><code>自定义 Hook</code> 是一个<code>函数</code>，其名称以 <code>“use” 开头</code>，函数内部<code>可以调用</code>其他的 <code>Hook</code>。</li><li><code>自定义 Hook</code> 是一种自然遵循 <code>Hook 设计</code>的约定，而并<code>不是 React</code> 的<code>特性</code>。</li></ul><h4 style="color:red;">自定义 Hook 必须以 “use” 开头吗？</h4><ul><li><code>必须如此。</code>这个约定非常重要。不遵循的话，由于<code>无法判断</code>某个函数是<code>否包含对其内部 Hook 的调用</code>，<code>React</code> 将无法自动检查你的 <code>Hook</code> 是否违反了 <code>Hook 的规则</code>。</li></ul><h4 style="color:red;">在两个组件中使用相同的 Hook 会共享 state 吗？</h4><ul><li><code>不会。</code> <code>自定义 Hook</code> 是一种<code>重用状态逻辑的机制</code>(例如设置为订阅并存储当前值)，所以每次使用<code>自定义 Hook </code>时，其中的所有 <code>state</code> 和<code>副作用</code>都是<code>完全隔离的</code>。</li></ul><h4 style="color:red;">自定义 Hook 如何获取独立的 state？</h4><ul><li>每次调用 <code>Hook</code>，它都会获取<code>独立的 state</code>；我们可以在一个组件中<code>多次调用 useState 和 useEffect</code>，它们是<code>完全独立的</code>。</li></ul>`,45);function r(u,p){return t(),d("div",null,[n,e(),l,e(" 1.在组件之间复用状态逻辑很难 "),i])}const f=c(s,[["render",r],["__file","hook.html.vue"]]),m=JSON.parse('{"path":"/document/react/hook.html","title":"hooks","lang":"zh-CN","frontmatter":{"date":"2022-08-19T00:00:00.000Z","author":"Mr.Ding","category":["React","Hooks"],"tag":["useState","useEffect"],"sticky":1,"star":1,"description":"hooks hooks的使用 为什么要用Hook? 1.在组件之间复用状态逻辑很难 Hook 使你在无需修改组件结构的情况下复用状态逻辑。 2.复杂组件变得难以理解 Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。 3.难以理解的...","head":[["meta",{"property":"og:url","content":"https://dyywork.github.io/blog/document/react/hook.html"}],["meta",{"property":"og:site_name","content":"莫名点"}],["meta",{"property":"og:title","content":"hooks"}],["meta",{"property":"og:description","content":"hooks hooks的使用 为什么要用Hook? 1.在组件之间复用状态逻辑很难 Hook 使你在无需修改组件结构的情况下复用状态逻辑。 2.复杂组件变得难以理解 Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。 3.难以理解的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-09-06T01:55:04.000Z"}],["meta",{"property":"article:author","content":"Mr.Ding"}],["meta",{"property":"article:tag","content":"useState"}],["meta",{"property":"article:tag","content":"useEffect"}],["meta",{"property":"article:published_time","content":"2022-08-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2022-09-06T01:55:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"hooks\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-08-19T00:00:00.000Z\\",\\"dateModified\\":\\"2022-09-06T01:55:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Ding\\"}]}"]]},"headers":[{"level":2,"title":"hooks的使用","slug":"hooks的使用","link":"#hooks的使用","children":[]},{"level":2,"title":"useState","slug":"usestate","link":"#usestate","children":[]},{"level":2,"title":"useEffect","slug":"useeffect","link":"#useeffect","children":[{"level":3,"title":"1.useEffect 介绍","slug":"_1-useeffect-介绍","link":"#_1-useeffect-介绍","children":[]},{"level":3,"title":"2.需要清除的 effect","slug":"_2-需要清除的-effect","link":"#_2-需要清除的-effect","children":[]}]},{"level":2,"title":"Hook 规则","slug":"hook-规则","link":"#hook-规则","children":[]},{"level":2,"title":"自定义Hook","slug":"自定义hook","link":"#自定义hook","children":[]}],"git":{"createdTime":1661481185000,"updatedTime":1662429304000,"contributors":[{"name":"dingyongya","email":"yahya_dyy@163.com","commits":6}]},"readingTime":{"minutes":4.46,"words":1338},"filePathRelative":"document/react/hook.md","localizedDate":"2022年8月19日","excerpt":"\\n<h2>hooks的使用</h2>\\n<h4 style=\\"color: red\\">为什么要用Hook?</h4> <br>\\n1.在组件之间复用状态逻辑很难\\n<ul>\\n<li><code>Hook</code> 使你在无需修改组件结构的情况下复用状态逻辑。</li>\\n</ul>\\n<p>2.复杂组件变得难以理解</p>\\n<ul>\\n<li><code>Hook</code> 将组件中<code>相互关联</code>的部分<code>拆分</code>成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 <code>reducer</code> 来管理组件的内部状态，使其更加可预测。</li>\\n</ul>","autoDesc":true}');export{f as comp,m as data};
